#!/usr/bin/env ruby
# frozen_string_literal: true

# Test MCP 2025-06-18 Protocol Features
#
# This script tests the four MCP 2025-06-18 protocol features:
# - Logging (logging/setLevel + notifications/message)
# - Roots (set_roots + notifications/roots/list_changed)
# - Completion (completion/complete for autocomplete suggestions)
# - Sampling (sampling/createMessage - server requests LLM completion from client)
#
# Prerequisites:
# 1. Install Flask: pip install flask
# 2. Start the enhanced server: python examples/echo_server_streamable.py
# 3. Run this client: bundle exec ruby examples/test_mcp_protocol_features.rb

require 'bundler/setup'
require_relative '../lib/mcp_client'
require 'logger'

# Create a logger with debug level to see all activity
logger = Logger.new($stdout)
logger.level = ENV['DEBUG'] ? Logger::DEBUG : Logger::INFO
logger.formatter = proc do |severity, datetime, _progname, msg|
  "#{datetime.strftime('%H:%M:%S')} [#{severity}] #{msg}\n"
end

puts 'üß™ MCP 2025-06-18 Protocol Features Test'
puts '=' * 60

# Server URL
server_url = 'http://localhost:8931/mcp'

puts "üì° Connecting to Enhanced Echo Server at #{server_url}"
puts 'Protocol: MCP 2025-06-18'
puts

# Track received log notifications
log_notifications = []
log_mutex = Mutex.new

# Track sampling requests received
sampling_requests_received = []
sampling_mutex = Mutex.new

begin
  # Create MCP client with sampling handler
  # The sampling_handler is called when the server sends sampling/createMessage requests
  # Note: With arity 1, the handler receives `messages` (Array), not the full params Hash
  # With arity 4, it receives (messages, model_preferences, system_prompt, max_tokens)
  sampling_handler = lambda do |messages, _model_preferences, system_prompt, _max_tokens|
    sampling_mutex.synchronize do
      sampling_requests_received << { messages: messages, system_prompt: system_prompt, time: Time.now }
    end

    # Extract the prompt from the messages
    prompt = messages&.first&.dig('content', 'text') || 'No prompt provided'

    puts "ü§ñ Sampling request received: #{prompt[0..50]}..."

    # Return a mock LLM response
    {
      'role' => 'assistant',
      'content' => {
        'type' => 'text',
        'text' => "This is a mock LLM response to: \"#{prompt}\". In a real implementation, this would be generated by an actual LLM like Claude or GPT."
      },
      'model' => 'mock-llm-v1',
      'stopReason' => 'endTurn'
    }
  end

  client = MCPClient.connect(server_url,
                             read_timeout: 60,
                             retries: 3,
                             logger: logger,
                             sampling_handler: sampling_handler)

  # Set up notification handler to capture log messages
  # Note: on_notification receives (server, method, params)
  client.on_notification do |_server, method, params|
    case method
    when 'notifications/message'
      log_mutex.synchronize do
        log_notifications << { level: params['level'], logger: params['logger'], data: params['data'], time: Time.now }
      end
      puts "üìù Log [#{params['level']}] #{params['logger']}: #{params['data']}"
    when 'notification/server_status'
      puts "üìä Server Status: #{params['message']}"
    when 'notification/progress'
      puts "‚è≥ Progress: #{params['progress']}% - #{params['message']}"
    else
      puts "üîî Notification [#{method}]: #{params.inspect}"
    end
  end

  puts '‚úÖ Connected successfully!'
  puts
  sleep 1 # Give the connection a moment to stabilize

  # ============================================================
  # Test 1: Logging Feature
  # ============================================================
  puts '=' * 60
  puts 'Test 1: Logging Feature (logging/setLevel + notifications/message)'
  puts '-' * 60
  puts

  # Clear any previous log notifications
  log_mutex.synchronize { log_notifications.clear }

  # Test setting log level to debug
  puts '1a. Setting log level to "debug"...'
  begin
    client.set_log_level('debug')
    puts '    ‚úÖ Log level set to debug'
  rescue StandardError => e
    puts "    ‚ùå Error setting log level: #{e.message}"
  end
  puts

  # Trigger some operations that should generate log messages
  puts '1b. Triggering operations to generate log messages...'

  # The completion request should generate a debug log message on the server
  client.complete(
    ref: { 'type' => 'ref/prompt', 'name' => 'greeting' },
    argument: { 'name' => 'name', 'value' => 'A' }
  )

  # Wait a moment for async notifications to arrive
  sleep 1.5

  # Check if we received any log notifications
  log_mutex.synchronize do
    if log_notifications.empty?
      puts '    ‚ö†Ô∏è  No log notifications received yet (server may not be sending them)'
    else
      puts "    ‚úÖ Received #{log_notifications.length} log notification(s):"
      log_notifications.each do |log|
        puts "       - [#{log[:level]}] #{log[:logger]}: #{log[:data]}"
      end
    end
  end
  puts

  # Test setting log level to warning (should filter out debug/info messages)
  puts '1c. Setting log level to "warning"...'
  begin
    client.set_log_level('warning')
    puts '    ‚úÖ Log level set to warning'
  rescue StandardError => e
    puts "    ‚ùå Error setting log level: #{e.message}"
  end
  puts

  # ============================================================
  # Test 2: Roots Feature
  # ============================================================
  puts '=' * 60
  puts 'Test 2: Roots Feature (roots/list + notifications/roots/list_changed)'
  puts '-' * 60
  puts

  puts '2a. Setting roots on the client...'
  begin
    client.set_roots([
      { uri: 'file:///home/user/project', name: 'Project Root' },
      { uri: 'file:///home/user/config', name: 'Config Directory' }
    ])
    puts '    ‚úÖ Roots set successfully'
    puts '    Roots:'
    client.roots.each do |root|
      puts "       - #{root.name}: #{root.uri}"
    end
  rescue StandardError => e
    puts "    ‚ùå Error setting roots: #{e.message}"
  end
  puts

  # Wait for the notification to be sent and logged
  sleep 1

  puts '2b. Checking if server received roots/list_changed notification...'
  log_mutex.synchronize do
    roots_notifications = log_notifications.select { |l| l[:data].to_s.include?('roots') }
    if roots_notifications.any?
      puts '    ‚úÖ Server received roots notification:'
      roots_notifications.each do |log|
        puts "       - [#{log[:level]}] #{log[:data]}"
      end
    else
      puts '    ‚ö†Ô∏è  No roots notification logged (server may not log this)'
    end
  end
  puts

  # ============================================================
  # Test 3: Completion Feature
  # ============================================================
  puts '=' * 60
  puts 'Test 3: Completion Feature (completion/complete)'
  puts '-' * 60
  puts

  # Test completion for prompt argument
  puts '3a. Getting completions for greeting prompt "name" argument starting with "A"...'
  begin
    result = client.complete(
      ref: { 'type' => 'ref/prompt', 'name' => 'greeting' },
      argument: { 'name' => 'name', 'value' => 'A' }
    )

    completion = result['completion'] || result
    values = completion['values'] || []
    total = completion['total'] || values.length
    has_more = completion['hasMore'] || false

    puts "    ‚úÖ Received #{values.length} completions (total: #{total}, hasMore: #{has_more})"
    puts "    Values: #{values.join(', ')}"
  rescue StandardError => e
    puts "    ‚ùå Error: #{e.message}"
  end
  puts

  # Test completion for code_review language argument
  puts '3b. Getting completions for code_review prompt "language" argument starting with "r"...'
  begin
    result = client.complete(
      ref: { 'type' => 'ref/prompt', 'name' => 'code_review' },
      argument: { 'name' => 'language', 'value' => 'r' }
    )

    completion = result['completion'] || result
    values = completion['values'] || []
    puts "    ‚úÖ Received #{values.length} completions"
    puts "    Values: #{values.join(', ')}"
  rescue StandardError => e
    puts "    ‚ùå Error: #{e.message}"
  end
  puts

  # Test completion for resource URI
  puts '3c. Getting completions for resource URIs containing "config"...'
  begin
    result = client.complete(
      ref: { 'type' => 'ref/resource', 'uri' => 'file:///' },
      argument: { 'name' => 'uri', 'value' => 'config' }
    )

    completion = result['completion'] || result
    values = completion['values'] || []
    puts "    ‚úÖ Received #{values.length} completions"
    puts "    Values: #{values.join(', ')}"
  rescue StandardError => e
    puts "    ‚ùå Error: #{e.message}"
  end
  puts

  # ============================================================
  # Test 4: Sampling Feature
  # ============================================================
  puts '=' * 60
  puts 'Test 4: Sampling Feature (sampling/createMessage)'
  puts '-' * 60
  puts

  # Set log level back to info for sampling test
  client.set_log_level('info')

  # Clear sampling requests
  sampling_mutex.synchronize { sampling_requests_received.clear }

  puts '4a. Calling ask_llm tool (triggers sampling/createMessage request)...'
  puts '    The server will send a sampling request to this client,'
  puts '    and our sampling_handler will return a mock LLM response.'
  puts

  begin
    result = client.call_tool('ask_llm', {
                                prompt: 'What is the meaning of life?',
                                max_tokens: 100
                              })

    output = result['content']&.first&.dig('text')
    puts '    ‚úÖ Tool call completed!'
    puts "    Response: #{output}"
  rescue MCPClient::Errors::ToolCallError => e
    puts "    ‚ùå Tool call error: #{e.message}"
  rescue StandardError => e
    puts "    ‚ùå Error: #{e.class}: #{e.message}"
  end
  puts

  # Check if sampling handler was invoked
  sampling_mutex.synchronize do
    if sampling_requests_received.empty?
      puts '    ‚ö†Ô∏è  No sampling requests were received by our handler'
      puts '       (This might happen if the server timed out before our response)'
    else
      puts "    ‚úÖ Sampling handler was invoked #{sampling_requests_received.length} time(s)"
      sampling_requests_received.each_with_index do |req, idx|
        messages = req[:messages] || []
        prompt = messages.first&.dig('content', 'text') || 'N/A'
        puts "       #{idx + 1}. Prompt: #{prompt[0..50]}..."
      end
    end
  end
  puts

  # ============================================================
  # Summary
  # ============================================================
  puts '=' * 60
  puts '‚ú® MCP 2025-06-18 Protocol Features Test Complete!'
  puts
  puts 'Summary:'

  # Logging summary
  log_count = log_mutex.synchronize { log_notifications.length }
  puts "  üìù Logging: #{log_count > 0 ? '‚úÖ' : '‚ö†Ô∏è'} Received #{log_count} log notification(s)"

  # Roots summary
  roots_count = client.roots&.length || 0
  puts "  üìÅ Roots: #{roots_count > 0 ? '‚úÖ' : '‚ö†Ô∏è'} #{roots_count} root(s) configured"

  # Completion summary
  puts '  üî§ Completion: ‚úÖ Autocomplete requests working'

  # Sampling summary
  sampling_count = sampling_mutex.synchronize { sampling_requests_received.length }
  puts "  ü§ñ Sampling: #{sampling_count > 0 ? '‚úÖ' : '‚ö†Ô∏è'} Handler invoked #{sampling_count} time(s)"

  puts
  puts 'All MCP 2025-06-18 features have been tested!'

rescue MCPClient::Errors::ConnectionError => e
  puts "‚ùå Connection Error: #{e.message}"
  puts
  puts 'üí° Make sure the enhanced echo server is running:'
  puts '   python examples/echo_server_streamable.py'
rescue StandardError => e
  puts "‚ùå Unexpected Error: #{e.class}: #{e.message}"
  puts e.backtrace.first(5).join("\n") if ENV['DEBUG']
ensure
  puts
  puts 'üßπ Cleaning up...'
  client&.cleanup
  puts 'üëã Connection closed gracefully'
end
